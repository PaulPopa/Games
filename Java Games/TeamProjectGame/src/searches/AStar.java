package searches;

import entity.Unit;
import graph.GraphNode;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.PriorityQueue;
import java.util.Set;

/**
 * @author : First created by Evgeniy Kim with code by Evgeniy Kim
 * @date : 07/02/16, last edited by Evgeniy Kim on 20/02/16
 */
public class AStar {
    /**
     * Returns a path generated by the A* search, omits first node.
     *
     * @param unit the unit to search for
     * @param goal Goal Node
     * @return
     */
    public static List<GraphNode> search(Unit unit, GraphNode goal) {

        Set<GraphNode> visited = new LinkedHashSet<>();
        Map<GraphNode, GraphNode> pred = new LinkedHashMap<>();
        Map<GraphNode, Integer> D = new LinkedHashMap<>();// empty map, contains costs from origin along best known path
        Map<GraphNode, Integer> f = new LinkedHashMap<>();//records estimated total cost
        Comparator<GraphNode> p = (o1, o2) -> {
            int value = f.get(o1);
            int value1 = f.get(o2);
            if (value == value1) {
                return 0;
            }
            if (value < value1) {
                return -1;
            }
            return 1;
        };
        PriorityQueue<GraphNode> pending = new PriorityQueue<>(5, p);
        GraphNode start = unit.getPosition();
        pending.add(unit.getPosition());
        D.put(start, 0);
        f.put(start, distance(start, goal));

        while (!pending.isEmpty()) {
            GraphNode n = pending.poll();// dequeue with smallest f value;

            if (n.equals(goal)) {
                visited.add(n);
                ArrayList<GraphNode> pathList = new ArrayList<>(); // make list, add goal first
                if (start == goal) {
                    //@TODO
                    pathList.add(start);
                    unit.setVisited(new ArrayList<>(visited));
                    unit.setRoute(pathList);
                    return pathList;
                } else {//not first, add goal
                    pathList.add(n);
                    n = pred.get(n); //get the one before goal
                    while (n != start) {//add rest
                        pathList.add(n);
                        n = pred.get(n);
                    }
                    // pathList.add(start);		//add first
                    Collections.reverse(pathList);
                    unit.setVisited(new ArrayList<>(visited));
                    unit.setRoute(pathList);
                    return pathList;
                }

            }

            visited.add(n);
            for (GraphNode s : n.getSuccessors()) {
                if (!visited.contains(s) && (s.getBlockade() == null || s.getBlockade().isBreakable())) {
                    int cost = D.get(n) + distance(n, s);
                    if (!pending.contains(s) || cost < D.get(s)) {
                        pred.put(s, n);
                        D.put(s, cost);
                        f.put(s, D.get(s) + distance(s, goal));
                        if (!pending.contains(s)) {
                            pending.add(s);
                        }
                    }
                }
            }
        }
        return null;
    }

    public static int distance(GraphNode a, GraphNode b) {
        int xDistance = Math.abs(a.getX() - b.getX());  //CHANGE DEPENDING ON IMPLEMENTATION
        int yDistance = Math.abs(a.getY() - b.getY());  //CHANGE DEPENDING ON IMPLEMENTATION
        return (int) Math.round(Math.sqrt((xDistance * xDistance) + (yDistance * yDistance)));
    }

}
